export declare const flydeCoreTypes = "// Generated by dts-bundle v0.7.3\n// Dependencies for this module:\n//   ../../../../dependency-graph\n//   ../../../../zod\n//   ../../../../rxjs\n//   ../../../../debug\n//   ../../../../react\n\ndeclare module '@flyde/core' {\n    export * from \"@flyde/core/common\";\n    import { Pos } from \"@flyde/core/common\";\n    import { FlydeFlow } from \"@flyde/core/flow-schema\";\n    import { VisualNode, InputPinsConfig } from \"@flyde/core/node\";\n    export * from \"@flyde/core/connect/helpers\";\n    export * from \"@flyde/core/execute\";\n    export * from \"@flyde/core/simplified-execute\";\n    export * from \"@flyde/core/node\";\n    export * from \"@flyde/core/flow-schema\";\n    export * from \"@flyde/core/types/connections\";\n    export * from \"@flyde/core/types/editor\";\n    export * from \"@flyde/core/configurable-nodes/configurable-nodes\";\n    export { extractInputsFromValue, replaceInputsInValue, renderDerivedString, evaluateCondition, evaluateFieldVisibility, createInputGroup, } from \"@flyde/core/configurable-nodes/configurable-node-utils\";\n    export * from \"@flyde/core/remote-debugger\";\n    export * from \"@flyde/core/run-node\";\n    export interface InstanceViewData {\n        id: string;\n        nodeIdOrGroup: string | VisualNode;\n        pos: Pos;\n        visibleOptionalInputs?: string[];\n        inputConfig: InputPinsConfig;\n    }\n    export interface FlowJob {\n        flow: FlydeFlow;\n        id: string;\n    }\n    export * from \"@flyde/core/telemetry\";\n}\n\ndeclare module '@flyde/core/common' {\n    export * from \"@flyde/core/common/test-data-creator\";\n    export * from \"@flyde/core/common/utils\";\n    export * from \"@flyde/core/common/debug-logger\";\n    export * from \"@flyde/core/common/capped-array-debounce\";\n    export * from \"@flyde/core/common/utils\";\n    export * from \"@flyde/core/common/value-builders\";\n    export * from \"@flyde/core/common/data-shaper\";\n    export * from \"@flyde/core/common/full-ins-id-path\";\n    import { DepGraph as _DepGraph } from \"dependency-graph\";\n    export const DepGraph: typeof _DepGraph;\n}\n\ndeclare module '@flyde/core/flow-schema' {\n    import { z } from \"zod\";\n    import { VisualNode, NodeDefinition } from \"@flyde/core/node\";\n    import { CodeNode } from \"@flyde/core/configurable-nodes/configurable-nodes\";\n    export type FlydeFlow = {\n        /** @deprecated */\n        imports?: Record<string, string[]>;\n        node: VisualNode;\n    };\n    export type ImportedNodeDefinition = NodeDefinition;\n    export type ImportedNode = VisualNode | CodeNode;\n    export type ImportedNodeDef = NodeDefinition;\n    export const flydeFlowSchema: z.ZodObject<{\n        /** @deprecated */\n        imports: z.ZodDefault<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, \"many\">]>>>>;\n        node: z.ZodIntersection<z.ZodObject<{\n            instances: z.ZodArray<z.ZodObject<{\n                pos: z.ZodDefault<z.ZodObject<{\n                    x: z.ZodNumber;\n                    y: z.ZodNumber;\n                }, \"strict\", z.ZodTypeAny, {\n                    x?: number;\n                    y?: number;\n                }, {\n                    x?: number;\n                    y?: number;\n                }>>;\n                id: z.ZodString;\n                inputConfig: z.ZodDefault<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodDiscriminatedUnion<\"mode\", [z.ZodObject<{\n                    mode: z.ZodLiteral<\"queue\">;\n                }, \"strict\", z.ZodTypeAny, {\n                    mode?: \"queue\";\n                }, {\n                    mode?: \"queue\";\n                }>, z.ZodObject<{\n                    mode: z.ZodLiteral<\"sticky\">;\n                }, \"strict\", z.ZodTypeAny, {\n                    mode?: \"sticky\";\n                }, {\n                    mode?: \"sticky\";\n                }>]>>>>;\n                visibleInputs: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n                visibleOutputs: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n                displayName: z.ZodOptional<z.ZodString>;\n                nodeId: z.ZodOptional<z.ZodString>;\n                macroId: z.ZodOptional<z.ZodString>;\n                macroData: z.ZodOptional<z.ZodAny>;\n                config: z.ZodOptional<z.ZodAny>;\n                node: z.ZodOptional<z.ZodAny>;\n                type: z.ZodOptional<z.ZodEnum<[\"code\", \"visual\"]>>;\n                source: z.ZodOptional<z.ZodObject<{\n                    type: z.ZodString;\n                    data: z.ZodAny;\n                }, \"strip\", z.ZodTypeAny, {\n                    type?: string;\n                    data?: any;\n                }, {\n                    type?: string;\n                    data?: any;\n                }>>;\n                style: z.ZodOptional<z.ZodObject<{\n                    size: z.ZodOptional<z.ZodEnum<[\"small\", \"regular\", \"large\"]>>;\n                    icon: z.ZodOptional<z.ZodAny>;\n                    color: z.ZodOptional<z.ZodString>;\n                    cssOverride: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;\n                }, \"strip\", z.ZodTypeAny, {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                }, {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                }>>;\n            }, \"strip\", z.ZodTypeAny, {\n                id?: string;\n                displayName?: string;\n                config?: any;\n                node?: any;\n                type?: \"code\" | \"visual\";\n                nodeId?: string;\n                source?: {\n                    type?: string;\n                    data?: any;\n                };\n                macroId?: string;\n                macroData?: any;\n                inputConfig?: Record<string, {\n                    mode?: \"queue\";\n                } | {\n                    mode?: \"sticky\";\n                }>;\n                visibleInputs?: string[];\n                visibleOutputs?: string[];\n                style?: {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                };\n                pos?: {\n                    x?: number;\n                    y?: number;\n                };\n            }, {\n                id?: string;\n                displayName?: string;\n                config?: any;\n                node?: any;\n                type?: \"code\" | \"visual\";\n                nodeId?: string;\n                source?: {\n                    type?: string;\n                    data?: any;\n                };\n                macroId?: string;\n                macroData?: any;\n                inputConfig?: Record<string, {\n                    mode?: \"queue\";\n                } | {\n                    mode?: \"sticky\";\n                }>;\n                visibleInputs?: string[];\n                visibleOutputs?: string[];\n                style?: {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                };\n                pos?: {\n                    x?: number;\n                    y?: number;\n                };\n            }>, \"many\">;\n            connections: z.ZodArray<z.ZodObject<{\n                from: z.ZodObject<{\n                    insId: z.ZodString;\n                    pinId: z.ZodString;\n                }, \"strict\", z.ZodTypeAny, {\n                    pinId?: string;\n                    insId?: string;\n                }, {\n                    pinId?: string;\n                    insId?: string;\n                }>;\n                to: z.ZodObject<{\n                    insId: z.ZodString;\n                    pinId: z.ZodString;\n                }, \"strict\", z.ZodTypeAny, {\n                    pinId?: string;\n                    insId?: string;\n                }, {\n                    pinId?: string;\n                    insId?: string;\n                }>;\n                delayed: z.ZodOptional<z.ZodBoolean>;\n                hidden: z.ZodOptional<z.ZodBoolean>;\n            }, \"strict\", z.ZodTypeAny, {\n                from?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                to?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                delayed?: boolean;\n                hidden?: boolean;\n            }, {\n                from?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                to?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                delayed?: boolean;\n                hidden?: boolean;\n            }>, \"many\">;\n        }, \"strip\", z.ZodTypeAny, {\n            connections?: {\n                from?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                to?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                delayed?: boolean;\n                hidden?: boolean;\n            }[];\n            instances?: {\n                id?: string;\n                displayName?: string;\n                config?: any;\n                node?: any;\n                type?: \"code\" | \"visual\";\n                nodeId?: string;\n                source?: {\n                    type?: string;\n                    data?: any;\n                };\n                macroId?: string;\n                macroData?: any;\n                inputConfig?: Record<string, {\n                    mode?: \"queue\";\n                } | {\n                    mode?: \"sticky\";\n                }>;\n                visibleInputs?: string[];\n                visibleOutputs?: string[];\n                style?: {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                };\n                pos?: {\n                    x?: number;\n                    y?: number;\n                };\n            }[];\n        }, {\n            connections?: {\n                from?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                to?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                delayed?: boolean;\n                hidden?: boolean;\n            }[];\n            instances?: {\n                id?: string;\n                displayName?: string;\n                config?: any;\n                node?: any;\n                type?: \"code\" | \"visual\";\n                nodeId?: string;\n                source?: {\n                    type?: string;\n                    data?: any;\n                };\n                macroId?: string;\n                macroData?: any;\n                inputConfig?: Record<string, {\n                    mode?: \"queue\";\n                } | {\n                    mode?: \"sticky\";\n                }>;\n                visibleInputs?: string[];\n                visibleOutputs?: string[];\n                style?: {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                };\n                pos?: {\n                    x?: number;\n                    y?: number;\n                };\n            }[];\n        }>, z.ZodObject<{\n            id: z.ZodOptional<z.ZodString>;\n            inputs: z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodObject<{\n                mode: z.ZodEnum<[\"required\", \"optional\", \"required-if-connected\"]>;\n                /** @deprecated */\n                type: z.ZodOptional<z.ZodString>;\n                description: z.ZodOptional<z.ZodString>;\n                defaultValue: z.ZodOptional<z.ZodAny>;\n            }, \"strip\", z.ZodTypeAny, {\n                description?: string;\n                type?: string;\n                mode?: \"optional\" | \"required\" | \"required-if-connected\";\n                defaultValue?: any;\n            }, {\n                description?: string;\n                type?: string;\n                mode?: \"optional\" | \"required\" | \"required-if-connected\";\n                defaultValue?: any;\n            }>]>>;\n            outputs: z.ZodRecord<z.ZodString, z.ZodObject<{\n                /** @deprecated */\n                type: z.ZodOptional<z.ZodString>;\n                optional: z.ZodOptional<z.ZodBoolean>;\n                delayed: z.ZodOptional<z.ZodBoolean>;\n                description: z.ZodOptional<z.ZodString>;\n            }, \"strip\", z.ZodTypeAny, {\n                description?: string;\n                optional?: boolean;\n                type?: string;\n                delayed?: boolean;\n            }, {\n                description?: string;\n                optional?: boolean;\n                type?: string;\n                delayed?: boolean;\n            }>>;\n            inputsPosition: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{\n                x: z.ZodNumber;\n                y: z.ZodNumber;\n            }, \"strict\", z.ZodTypeAny, {\n                x?: number;\n                y?: number;\n            }, {\n                x?: number;\n                y?: number;\n            }>>>;\n            outputsPosition: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{\n                x: z.ZodNumber;\n                y: z.ZodNumber;\n            }, \"strict\", z.ZodTypeAny, {\n                x?: number;\n                y?: number;\n            }, {\n                x?: number;\n                y?: number;\n            }>>>;\n            completionOutputs: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n            reactiveInputs: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n            defaultStyle: z.ZodOptional<z.ZodObject<{\n                size: z.ZodOptional<z.ZodEnum<[\"small\", \"regular\", \"large\"]>>;\n                icon: z.ZodOptional<z.ZodAny>;\n                color: z.ZodOptional<z.ZodString>;\n                cssOverride: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;\n            }, \"strip\", z.ZodTypeAny, {\n                size?: \"small\" | \"regular\" | \"large\";\n                icon?: any;\n                color?: string;\n                cssOverride?: Record<string, string>;\n            }, {\n                size?: \"small\" | \"regular\" | \"large\";\n                icon?: any;\n                color?: string;\n                cssOverride?: Record<string, string>;\n            }>>;\n            description: z.ZodOptional<z.ZodString>;\n            aliases: z.ZodOptional<z.ZodArray<z.ZodString, \"many\">>;\n        }, \"strip\", z.ZodTypeAny, {\n            inputs?: Record<string, string | {\n                description?: string;\n                type?: string;\n                mode?: \"optional\" | \"required\" | \"required-if-connected\";\n                defaultValue?: any;\n            }>;\n            outputs?: Record<string, {\n                description?: string;\n                optional?: boolean;\n                type?: string;\n                delayed?: boolean;\n            }>;\n            completionOutputs?: string[];\n            reactiveInputs?: string[];\n            id?: string;\n            description?: string;\n            aliases?: string[];\n            defaultStyle?: {\n                size?: \"small\" | \"regular\" | \"large\";\n                icon?: any;\n                color?: string;\n                cssOverride?: Record<string, string>;\n            };\n            inputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n            outputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n        }, {\n            inputs?: Record<string, string | {\n                description?: string;\n                type?: string;\n                mode?: \"optional\" | \"required\" | \"required-if-connected\";\n                defaultValue?: any;\n            }>;\n            outputs?: Record<string, {\n                description?: string;\n                optional?: boolean;\n                type?: string;\n                delayed?: boolean;\n            }>;\n            completionOutputs?: string[];\n            reactiveInputs?: string[];\n            id?: string;\n            description?: string;\n            aliases?: string[];\n            defaultStyle?: {\n                size?: \"small\" | \"regular\" | \"large\";\n                icon?: any;\n                color?: string;\n                cssOverride?: Record<string, string>;\n            };\n            inputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n            outputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n        }>>;\n    }, \"strict\", z.ZodTypeAny, {\n        node?: {\n            connections?: {\n                from?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                to?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                delayed?: boolean;\n                hidden?: boolean;\n            }[];\n            instances?: {\n                id?: string;\n                displayName?: string;\n                config?: any;\n                node?: any;\n                type?: \"code\" | \"visual\";\n                nodeId?: string;\n                source?: {\n                    type?: string;\n                    data?: any;\n                };\n                macroId?: string;\n                macroData?: any;\n                inputConfig?: Record<string, {\n                    mode?: \"queue\";\n                } | {\n                    mode?: \"sticky\";\n                }>;\n                visibleInputs?: string[];\n                visibleOutputs?: string[];\n                style?: {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                };\n                pos?: {\n                    x?: number;\n                    y?: number;\n                };\n            }[];\n        } & {\n            inputs?: Record<string, string | {\n                description?: string;\n                type?: string;\n                mode?: \"optional\" | \"required\" | \"required-if-connected\";\n                defaultValue?: any;\n            }>;\n            outputs?: Record<string, {\n                description?: string;\n                optional?: boolean;\n                type?: string;\n                delayed?: boolean;\n            }>;\n            completionOutputs?: string[];\n            reactiveInputs?: string[];\n            id?: string;\n            description?: string;\n            aliases?: string[];\n            defaultStyle?: {\n                size?: \"small\" | \"regular\" | \"large\";\n                icon?: any;\n                color?: string;\n                cssOverride?: Record<string, string>;\n            };\n            inputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n            outputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n        };\n        imports?: Record<string, string | string[]>;\n    }, {\n        node?: {\n            connections?: {\n                from?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                to?: {\n                    pinId?: string;\n                    insId?: string;\n                };\n                delayed?: boolean;\n                hidden?: boolean;\n            }[];\n            instances?: {\n                id?: string;\n                displayName?: string;\n                config?: any;\n                node?: any;\n                type?: \"code\" | \"visual\";\n                nodeId?: string;\n                source?: {\n                    type?: string;\n                    data?: any;\n                };\n                macroId?: string;\n                macroData?: any;\n                inputConfig?: Record<string, {\n                    mode?: \"queue\";\n                } | {\n                    mode?: \"sticky\";\n                }>;\n                visibleInputs?: string[];\n                visibleOutputs?: string[];\n                style?: {\n                    size?: \"small\" | \"regular\" | \"large\";\n                    icon?: any;\n                    color?: string;\n                    cssOverride?: Record<string, string>;\n                };\n                pos?: {\n                    x?: number;\n                    y?: number;\n                };\n            }[];\n        } & {\n            inputs?: Record<string, string | {\n                description?: string;\n                type?: string;\n                mode?: \"optional\" | \"required\" | \"required-if-connected\";\n                defaultValue?: any;\n            }>;\n            outputs?: Record<string, {\n                description?: string;\n                optional?: boolean;\n                type?: string;\n                delayed?: boolean;\n            }>;\n            completionOutputs?: string[];\n            reactiveInputs?: string[];\n            id?: string;\n            description?: string;\n            aliases?: string[];\n            defaultStyle?: {\n                size?: \"small\" | \"regular\" | \"large\";\n                icon?: any;\n                color?: string;\n                cssOverride?: Record<string, string>;\n            };\n            inputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n            outputsPosition?: Record<string, {\n                x?: number;\n                y?: number;\n            }>;\n        };\n        imports?: Record<string, string | string[]>;\n    }>;\n}\n\ndeclare module '@flyde/core/node' {\n    export * from \"@flyde/core/node/node-instance\";\n    export * from \"@flyde/core/types/pin-config\";\n    export * from \"@flyde/core/node/node-instance-error\";\n    export * from \"@flyde/core/node/node\";\n    export * from \"@flyde/core/node/configurable-value\";\n}\n\ndeclare module '@flyde/core/connect/helpers' {\n    import { InputPin, NodeDefinition, OutputPin } from \"@flyde/core/node\";\n    import { ConnectionData, ConnectionNode, ExternalConnectionNode, InternalConnectionNode } from \"@flyde/core/types/connections\";\n    export const THIS_INS_ID = \"__this\";\n    export const ERROR_PIN_ID = \"__error\";\n    export const TRIGGER_PIN_ID = \"__trigger\";\n    export const getNodeInputs: (node: NodeDefinition) => Record<string, InputPin>;\n    export const getNodeOutputs: (node: NodeDefinition) => Record<string, OutputPin>;\n    export const isExternalConnectionNode: (node: ConnectionNode) => node is ExternalConnectionNode;\n    export const isInternalConnectionNode: (node: ConnectionNode) => node is InternalConnectionNode;\n    export const isExternalConnection: ({ from, to }: ConnectionData) => boolean;\n    export const isInternalConnection: (conn: ConnectionData) => boolean;\n    export const externalConnectionNode: (pinId: string) => ExternalConnectionNode;\n    export const connectionNode: (insId: string, pinId: string) => ConnectionNode;\n    export const connectionNodeEquals: (conn1: ConnectionNode, conn2: ConnectionNode) => boolean;\n    export const connectionDataEquals: (cd1?: ConnectionData, cd2?: ConnectionData) => boolean;\n    export function connectionData(from: string, to: string, delayed?: boolean): ConnectionData;\n    export function connectionData(from: [string, string], to: [string, string], delayed?: boolean): ConnectionData;\n    export function connectionData(from: [string, string], to: [string], delayed?: boolean): ConnectionData;\n    export function connectionData(from: [string], to: [string, string], delayed?: boolean): ConnectionData;\n    export const connection: (from: ConnectionNode, to: ConnectionNode, delayed?: boolean) => ConnectionData;\n}\n\ndeclare module '@flyde/core/execute' {\n    import { Subject } from \"rxjs\";\n    export * from \"@flyde/core/execute/debugger\";\n    import { InternalCodeNode, NodeInputs, NodeOutputs, NodeInstanceError, NodeState, InternalNode } from \"@flyde/core/node\";\n    import { OMap, OMapF } from \"@flyde/core/common\";\n    import { Debugger } from \"@flyde/core/execute/debugger\";\n    export type SubjectMap = OMapF<Subject<any>>;\n    export type ExecutionState = Map<string, any>;\n    export type CancelFn = () => void;\n    export type InnerExecuteFn = (node: InternalNode, args: NodeInputs, outputs: NodeOutputs, insId: string) => CancelFn;\n    export type CodeExecutionData = {\n            node: InternalCodeNode;\n            inputs: NodeInputs;\n            outputs: NodeOutputs;\n            _debugger?: Debugger;\n            /**\n                * If the node is an instance of another node, this is the id of the instance.\n                * If the node is the root node, this is \"__root\".\n                * Used for debugger events and state namespacing\n                */\n            insId: string;\n            /**\n                * A full path of ancestor insIds, separated by dots.\n                * Used for debugger events and state namespacing\n                */\n            ancestorsInsIds?: string;\n            extraContext?: Record<string, any>;\n            mainState: OMap<NodeState>;\n            onError: (err: any) => void;\n            onBubbleError: (err: any) => void;\n            onCompleted?: (data: any) => void;\n            onStarted?: () => void;\n    };\n    export const INNER_STATE_SUFFIX = \"_inner\";\n    export const INPUTS_STATE_SUFFIX = \"_inputs\";\n    export type ExecuteFn = (params: ExecuteParams) => CancelFn;\n    export type ExecuteParams = {\n            node: InternalNode;\n            inputs: NodeInputs;\n            outputs: NodeOutputs;\n            _debugger?: Debugger;\n            insId?: string;\n            ancestorsInsIds?: string;\n            mainState?: OMap<NodeState>;\n            onBubbleError?: (err: NodeInstanceError) => void;\n            extraContext?: Record<string, any>;\n            onCompleted?: (data: any) => void;\n            onStarted?: () => void;\n    };\n    export const ROOT_INS_ID = \"__root\";\n    export const GLOBAL_STATE_NS = \"____global\";\n    export const execute: ExecuteFn;\n}\n\ndeclare module '@flyde/core/simplified-execute' {\n    import { InternalNode } from \"@flyde/core/\";\n    import { ExecuteParams } from \"@flyde/core/execute\";\n    export const simplifiedExecute: (nodeToRun: InternalNode, inputs?: Record<string, any>, onOutput?: (key: string, data: any) => void, otherParams?: Partial<ExecuteParams>) => import(\"./execute\").CancelFn;\n}\n\ndeclare module '@flyde/core/types/connections' {\n    import { THIS_INS_ID } from \"@flyde/core/connect/helpers\";\n    export type ConnectionData = {\n        from: ConnectionNode;\n        to: ConnectionNode;\n        delayed?: boolean;\n        hidden?: boolean;\n    };\n    export type ExternalConnectionNode = {\n        insId: typeof THIS_INS_ID;\n        pinId: string;\n    };\n    export type InternalConnectionNode = {\n        insId: string;\n        pinId: string;\n    };\n    export type ConnectionNode = ExternalConnectionNode | InternalConnectionNode;\n}\n\ndeclare module '@flyde/core/types/editor' {\n    import { CodeNodeDefinition, CodeNodeInstance, InternalCodeNode, ConfigurableEditorConfigResolved, ConfigurableEditorConfigStructured, NodeInstance, VisualNode } from \"@flyde/core/node\";\n    export type EditorCodeNodeDefinition = CodeNodeDefinition & {\n        editorConfig: ConfigurableEditorConfigStructured | {\n            type: \"custom\";\n            editorComponentBundleContent: string;\n        };\n    };\n    export type EditorNode = EditorCodeNodeDefinition | EditorVisualNode;\n    export type EditorCodeNodeInstance = CodeNodeInstance & {\n        node: EditorCodeNodeDefinition;\n    };\n    export type EditorNodeInstance = NodeInstance & {\n        node: EditorNode;\n    };\n    export type EditorVisualNode = Omit<VisualNode, \"instances\"> & {\n        instances: EditorNodeInstance[];\n    };\n    export interface EditorNodeParams {\n        sourceCode: string;\n        editorConfig: ConfigurableEditorConfigResolved;\n        isTrigger: boolean;\n    }\n    export function internalCodeNodeToEditorNode(internalNode: InternalCodeNode, { editorConfig, isTrigger, sourceCode }: EditorNodeParams): EditorNode;\n}\n\ndeclare module '@flyde/core/configurable-nodes/configurable-nodes' {\n    import { InternalCodeNode, InputPin, OutputPin, InternalMacroNode, NodeStyle, InputMode } from \"@flyde/core/\";\n    export * from \"@flyde/core/configurable-nodes/configurable-node-utils\";\n    import { SecretTypeData } from \"@flyde/core/node/configurable-value\";\n    export type StaticOrDerived<T, Config> = T | ((config: Config) => T);\n    export interface BaseCodeNodeData<Config = any> {\n            mode?: \"simple\" | \"advanced\";\n            id: string;\n            namespace?: string;\n            menuDisplayName?: string;\n            menuDescription?: string;\n            displayName?: StaticOrDerived<string, Config>;\n            description?: StaticOrDerived<string, Config>;\n            overrideNodeBodyHtml?: StaticOrDerived<string, Config>;\n            aliases?: string[];\n            icon?: string;\n            completionOutputs?: StaticOrDerived<string[], Config>;\n            run: InternalCodeNode[\"run\"];\n            sourceCode?: string;\n            /**\n                * Whether this node is a trigger node.\n                * If true, the node will be treated as a trigger node and will not be editable.\n                * Experimental\n                * @default false\n                */\n            isTrigger?: boolean;\n    }\n    export interface SimpleCodeNode<Config> extends BaseCodeNodeData<Config> {\n            inputs: Record<string, InputConfig>;\n            outputs: Record<string, {\n                    description?: string;\n            }>;\n    }\n    export interface AdvancedCodeNode<Config> extends BaseCodeNodeData<Config> {\n            mode: \"advanced\";\n            inputs: StaticOrDerived<Record<string, InputPin>, Config>;\n            outputs: StaticOrDerived<Record<string, OutputPin>, Config>;\n            reactiveInputs?: StaticOrDerived<string[], Config>;\n            defaultConfig: Config;\n            editorConfig?: InternalMacroNode<Config>[\"editorConfig\"];\n            defaultStyle?: NodeStyle;\n    }\n    export type CodeNode<Config = any> = SimpleCodeNode<Config> | AdvancedCodeNode<Config>;\n    export type InputConfig = {\n            defaultValue?: any;\n            /**\n                * The label displayed above the input field.\n                * If not provided, the description will be used as the label.\n                * @recommended\n                */\n            label?: string;\n            description?: string;\n            mode?: InputMode | \"reactive\";\n            /**\n                * Whether the type of this input can be changed in the editor.\n                * When false, the \"Change type\" button will not be shown and the input won't be exposed as an input pin.\n                * @default true\n                */\n            typeConfigurable?: boolean;\n            aiCompletion?: {\n                    prompt: string;\n                    placeholder?: string;\n                    jsonMode?: boolean;\n            };\n            /**\n                * Optional condition that determines whether this input should be shown.\n                * If the condition evaluates to false, the input will be hidden.\n                *\n                * Uses a string expression like \"method !== 'GET'\" that will be evaluated against the config.\n                * The expression can reference other field values directly by their key.\n                *\n                * @example\n                * condition: \"method !== 'GET'\"\n                */\n            condition?: string;\n            /**\n                * Optional group configuration for organizing inputs.\n                * When specified, this input will be treated as a group container.\n                */\n            group?: {\n                    /**\n                        * The title of the group\n                        */\n                    title: string;\n                    /**\n                        * Whether the group is collapsible\n                        */\n                    collapsible?: boolean;\n                    /**\n                        * Whether the group is collapsed by default (only applies if collapsible is true)\n                        */\n                    defaultCollapsed?: boolean;\n                    /**\n                        * Fields to include in this group.\n                        * Can include both regular field keys and other group keys for nested groups.\n                        */\n                    fields: string[];\n                    /**\n                        * Optional parent group key. When specified, this group will be nested inside the parent group.\n                        * If not specified, the group will be at the top level.\n                        */\n                    parentGroup?: string;\n            };\n    } & EditorTypeConfig;\n    type EditorTypeConfig = {\n            [K in EditorType]: {\n                    editorType?: K;\n                    editorTypeData?: EditorTypeDataMap[K];\n            };\n    }[EditorType];\n    type EditorType = \"string\" | \"number\" | \"boolean\" | \"json\" | \"select\" | \"longtext\" | \"enum\" | \"secret\";\n    type EditorTypeDataMap = {\n            string: undefined;\n            number: {\n                    min?: number;\n                    max?: number;\n            };\n            boolean: undefined;\n            json: undefined;\n            select: {\n                    options: string[] | {\n                            value: string | number;\n                            label: string;\n                    }[];\n            };\n            longtext: {\n                    rows?: number;\n            };\n            enum: {\n                    options: string[];\n            };\n            secret: SecretTypeData;\n    };\n    export function isAdvancedCodeNode<Config>(node: CodeNode<Config>): node is AdvancedCodeNode<Config>;\n    export function isSimplifiedCodeNode<Config>(node: CodeNode<Config>): node is SimpleCodeNode<Config>;\n    export function isCodeNode<Config>(node: any): node is CodeNode<Config>;\n    export function processConfigurableNode(node: CodeNode, secrets?: Record<string, string>): InternalMacroNode<any>;\n}\n\ndeclare module '@flyde/core/configurable-nodes/configurable-node-utils' {\n    import { InputPin, ConfigurableValue, ConfigurableFieldDefinition, InternalMacroNode, InputMode } from \"@flyde/core/\";\n    import { InputConfig } from \"@flyde/core/configurable-nodes/configurable-nodes\";\n    export function extractInputsFromValue(_val: unknown, key: string, mode?: InputMode): Record<string, InputPin>;\n    export function replaceInputsInValue(inputs: Record<string, any>, value: ConfigurableValue, fieldName: string, ignoreMissingInputs?: boolean): ConfigurableValue[\"value\"];\n    export function renderConfigurableValue(value: ConfigurableValue, fieldName: string): string;\n    export function generateConfigEditor<Config>(config: Config, overrides?: Partial<Record<keyof Config, any>>): InternalMacroNode<Config>[\"editorConfig\"];\n    export function renderDerivedString(displayName: string, config: any): string;\n    /**\n        * Evaluates a string condition against a configuration object.\n        *\n        * @param condition The string expression to evaluate\n        * @param config The configuration object to evaluate against\n        * @returns True if the condition is met, false otherwise\n        */\n    export function evaluateCondition(condition: string | undefined, config: Record<string, any>): boolean;\n    /**\n        * Evaluates whether a field in a group hierarchy should be visible.\n        * A field is visible only if all its parent groups are visible.\n        *\n        * @param field The field to check visibility for\n        * @param fieldPath Array of parent group field IDs leading to this field\n        * @param allFields Map of all fields by their ID\n        * @param config The configuration object to evaluate conditions against\n        * @returns True if the field should be visible, false otherwise\n        */\n    export function evaluateFieldVisibility(fieldKey: string, groupHierarchy: string[], allFields: Record<string, ConfigurableFieldDefinition>, config: Record<string, any>): boolean;\n    /**\n        * Creates a group configuration for use in InputConfig.\n        *\n        * @param title The title of the group\n        * @param fields Array of field keys to include in the group\n        * @param options Additional group options\n        * @returns A group configuration object\n        */\n    export function createInputGroup(title: string, fields: string[], options?: {\n            collapsible?: boolean;\n            defaultCollapsed?: boolean;\n            parentGroup?: string;\n            condition?: string;\n    }): NonNullable<InputConfig[\"group\"]> & {\n            condition?: string;\n    };\n}\n\ndeclare module '@flyde/core/remote-debugger' {\n    export * from \"@flyde/core/remote-debugger/types\";\n    export * from \"@flyde/core/remote-debugger/utils\";\n}\n\ndeclare module '@flyde/core/run-node' {\n    import { ExecuteParams, InternalNode } from \"@flyde/core/\";\n    export interface RunNodeOptions extends Omit<ExecuteParams, 'node' | 'inputs' | 'outputs'> {\n        onOutputs?: (key: string, data: any) => void;\n        executionDelay?: number;\n    }\n    export function runNode<TInputs = any, TOutputs = any>(node: InternalNode, inputs: TInputs, options?: RunNodeOptions): Promise<TOutputs>;\n}\n\ndeclare module '@flyde/core/telemetry' {\n    export interface TelemetryEvent {\n        distinctId: string;\n        event: string;\n        properties?: Record<string, any>;\n    }\n    export function reportEvent(distinctId: string, event: string, properties?: Record<string, any>): void;\n}\n\ndeclare module '@flyde/core/common/test-data-creator' {\n    export type TestDataCreator<T> = (partial?: Partial<T>) => T;\n    export type ObjOrObjCreator<T> = T | (() => T);\n    export const testDataCreator: <T extends object>(defaults: ObjOrObjCreator<T>) => TestDataCreator<T>;\n}\n\ndeclare module '@flyde/core/common/utils' {\n    export type Pos = {\n        x: number;\n        y: number;\n    };\n    export interface OMap<T> {\n        [k: string]: T | undefined;\n    }\n    export interface OMapF<T> {\n        [k: string]: T;\n    }\n    export type Rect = Pos & {\n        w: number;\n        h: number;\n    };\n    export const intersectRect: (r1: Rect, r2: Rect) => boolean;\n    export const calcCenter: ({ w, h, x, y }: Rect) => Pos;\n    export const middlePos: (p1: Pos, p2: Pos) => Pos;\n    export const mapOMap: <T>(map: OMap<T>, cb: (key: string, item: T) => T) => OMap<T>;\n    export const filterOMap: <T>(map: OMap<T>, cb: (key: string, item: T) => boolean) => OMap<T>;\n    export const keys: <V>(map: OMap<V>) => string[];\n    export const values: <V>(map: OMap<V>) => V[];\n    export const entries: <V>(map: OMap<V>) => Array<[string, V]>;\n    export const fromEntries: <V>(entries: Array<[string, V]>) => OMap<V>;\n    export const pickFirst: <K>(v: [K, any]) => K;\n    export const pickSecond: <K>(v: [any, K]) => K;\n    export type RandomFunction = {\n        (): number;\n        (max: number): number;\n        (max: number, min: number): number;\n    };\n    export const randomInt: RandomFunction;\n    export const randomPos: (to?: number, from?: number) => Pos;\n    export const pickRandom: <K>(v: K[]) => K;\n    export const repeat: <T>(count: number, run: (idx: number) => T) => T[];\n    export const randomInts: (count: number, to?: number, from?: number) => number[];\n    export const shuffle: (arr: any[]) => any[];\n    export const containsAll: <T>(arr: T[], items: T[]) => boolean;\n    export const isDefined: <T>(o: T) => o is NonNullable<T>;\n    export const isPromise: <T>(o: any) => o is Promise<T>;\n    export const callFnOrFnPromise: (maybeFnOrFnPromise: void | Function | Promise<void | Function>, errorMsg: string) => void;\n    export const isOptionalType: (type: string) => boolean;\n    export const ensure: <T>(v: T, msg?: string) => NonNullable<T>;\n    export const removeDupes: (list: string[]) => string[];\n    export const noop: () => void;\n    export const delay: (ms: number) => Promise<unknown>;\n    export const eventually: (callback: () => void, timeout?: number, retryDelay?: number, errorSet?: Set<string>) => Promise<void>;\n    export function simplePluralize(count: number, noun: string): string;\n}\n\ndeclare module '@flyde/core/common/debug-logger' {\n    import type { Debugger as _Debugger } from \"debug\";\n    export type DebugLogger = _Debugger;\n    export const debugLogger: (subNs: string) => DebugLogger;\n}\n\ndeclare module '@flyde/core/common/capped-array-debounce' {\n    export const cappedArrayDebounce: <T>(cb: (items: T[]) => void, timeout: number, maxItems: number, maxTimeWaiting?: number) => {\n        addItem: (item: T) => void;\n        flush: () => void;\n        pendingItems: () => number;\n    };\n}\n\ndeclare module '@flyde/core/common/value-builders' {\n    import { OMap } from \"@flyde/core/common\";\n    export const compileStringTemplate: (template: string, inputs: OMap<any>) => string;\n    export const compileObjectTemplate: (template: string, inputs: OMap<any>) => any;\n}\n\ndeclare module '@flyde/core/common/data-shaper' {\n    export enum DataShapeType {\n        STRING = 0,\n        NUMBER = 1,\n        BOOLEAN = 2,\n        ARRAY = 3,\n        OBJECT = 4,\n        NULL = 5,\n        UNSUPPORTED = 6\n    }\n    export type DataShaperOptions = {\n        maxDepth: number;\n        maxArrayCheckIdx: number;\n    };\n    export type DataShape = DataShapeType | DataShape[] | {\n        [key: string]: DataShape;\n    };\n    export const dataShaper: (data: any, maxDepth?: number, maxArrayCheckIdx?: number) => DataShape;\n}\n\ndeclare module '@flyde/core/common/full-ins-id-path' {\n    export function fullInsIdPath(insId: string, ancestorsInsIds?: string): string;\n}\n\ndeclare module '@flyde/core/node/node-instance' {\n    import { InputPinsConfig, NodeDefinition, NodeStyle, Pos, VisualNode } from \"@flyde/core/\";\n    export interface NodeInstanceConfig {\n            inputConfig: InputPinsConfig;\n            visibleInputs?: string[];\n            visibleOutputs?: string[];\n            displayName?: string;\n            style?: NodeStyle;\n            id: string;\n            pos: Pos;\n    }\n    export interface CodeNodeSource {\n            type: \"package\" | \"file\" | \"custom\";\n            data: any;\n    }\n    export interface CodeNodeInstance extends NodeInstanceConfig {\n            type: \"code\";\n            nodeId: string;\n            source: CodeNodeSource;\n            config: any;\n            /**\n                * @deprecated Use nodeId instead\n                */\n            macroId?: string;\n            /**\n                * @deprecated Use config instead\n                */\n            macroData?: any;\n    }\n    export interface VisualNodeSourceRef {\n            type: \"package\" | \"file\" | \"custom\";\n            data: string;\n    }\n    export interface VisualNodeSourceInline {\n            type: \"inline\";\n            data: VisualNode;\n    }\n    export interface VisualNodeSourceSelf {\n            type: \"self\";\n    }\n    export type VisualNodeSource = VisualNodeSourceRef | VisualNodeSourceInline | VisualNodeSourceSelf;\n    export interface VisualNodeInstance extends NodeInstanceConfig {\n            type: \"visual\";\n            nodeId: string;\n            source: VisualNodeSource;\n    }\n    /** @deprecated */\n    export interface RefNodeInstance extends NodeInstanceConfig {\n            nodeId: string;\n            source?: CodeNodeSource;\n            config?: any;\n    }\n    /** @deprecated */\n    export interface InlineNodeInstance extends NodeInstanceConfig {\n            node: VisualNode;\n    }\n    export type NodeInstance = CodeNodeInstance | VisualNodeInstance;\n    export type ResolvedNodeInstance = NodeInstance;\n    export function codeNodeInstance(id: string, nodeId: string, source: CodeNodeSource, config?: any, inputConfig?: InputPinsConfig, pos?: Pos): CodeNodeInstance;\n    export const isCodeNodeInstance: (ins: NodeInstance) => ins is CodeNodeInstance;\n    export const isVisualNodeInstance: (ins: NodeInstance) => ins is VisualNodeInstance;\n    export const isInlineVisualNodeInstance: (ins: NodeInstance) => ins is VisualNodeInstance & {\n            source: VisualNodeSourceInline;\n    };\n    export const createInsId: (node: Pick<NodeDefinition, \"id\">) => string;\n}\n\ndeclare module '@flyde/core/types/pin-config' {\n    import { OMap } from \"@flyde/core/\";\n    export type QueueInputPinConfig = {\n        mode: \"queue\";\n    };\n    export type StickyInputPinConfig = {\n        mode: \"sticky\";\n    };\n    export type InputPinConfig = QueueInputPinConfig | StickyInputPinConfig;\n    export type InputPinsConfig = OMap<InputPinConfig>;\n    export const queueInputPinConfig: () => QueueInputPinConfig;\n    export const stickyInputPinConfig: () => StickyInputPinConfig;\n    export const isQueueInputPinConfig: (config: InputPinConfig | undefined) => config is QueueInputPinConfig;\n    export const isStickyInputPinConfig: (config: InputPinConfig | undefined) => config is StickyInputPinConfig;\n}\n\ndeclare module '@flyde/core/node/node-instance-error' {\n    export class NodeInstanceError extends Error {\n        fullInsIdsPath: string;\n        nodeId: string;\n        constructor(error: unknown, fullInsIdsPath: string, nodeId: string);\n    }\n}\n\ndeclare module '@flyde/core/node/node' {\n    import { OMapF } from \"@flyde/core/common\";\n    import { Subject } from \"rxjs\";\n    import { CancelFn, InnerExecuteFn } from \"@flyde/core/execute\";\n    import { ConfigurableNodeDefinition } from \"@flyde/core/node/configurable-value\";\n    import { VisualNode } from \"@flyde/core/types/external\";\n    import { CodeNodeDefinition } from \"@flyde/core/types/external\";\n    export type NodeState = Map<string, any>;\n    export type NodeAdvancedContext = {\n        execute: InnerExecuteFn;\n        insId: string;\n        ancestorsInsIds?: string;\n        state: NodeState;\n        globalState: NodeState;\n        onCleanup: (cb: Function) => void;\n        onError: (e: any) => void;\n        context: Record<string, any>;\n    };\n    export type RunNodeFunction = (args: OMapF<any>, o: OMapF<Subject<any>>, adv: NodeAdvancedContext) => void | CancelFn | Promise<void | CancelFn>;\n    export * from \"@flyde/core/node/configurable-value\";\n    export type NodeDefinition = VisualNode | CodeNodeDefinition;\n    export type NodeOrConfigurableDefinition = NodeDefinition | ConfigurableNodeDefinition<any>;\n    export * from \"@flyde/core/node/node-instance\";\n    export * from \"@flyde/core/types/internal\";\n    export * from \"@flyde/core/types/core\";\n    export * from \"@flyde/core/types/external\";\n    export * from \"@flyde/core/types/pins\";\n}\n\ndeclare module '@flyde/core/node/configurable-value' {\n    import { InternalCodeNode, CodeNodeDefinition, NodeMetadata, CodeNodeInstance } from \"@flyde/core/node/node\";\n    import type React from \"react\";\n    export function configurableValue(type: ConfigurableValue[\"type\"], value: ConfigurableValue[\"value\"]): ConfigurableValue;\n    import { CodeNode } from \"@flyde/core/configurable-nodes/configurable-nodes\";\n    export type ConfigurableFieldDefinitionType = \"string\" | \"number\" | \"boolean\" | \"json\" | \"select\" | \"longtext\" | \"dynamic\" | \"secret\";\n    export type ConfigurableValueTypeMap = {\n            string: string;\n            number: number;\n            boolean: boolean;\n            json: any;\n            select: string | number;\n            dynamic: undefined;\n            secret: string;\n    };\n    export type ConfigurableValue = {\n            [K in keyof ConfigurableValueTypeMap]: {\n                    type: K;\n                    value: ConfigurableValueTypeMap[K];\n            };\n    }[keyof ConfigurableValueTypeMap];\n    export type ConfigurableFieldDefinition = StringFieldDefinition | NumberFieldDefinition | BooleanFieldDefinition | JsonFieldDefinition | SelectFieldDefinition | LongTextFieldDefinition | GroupFieldDefinition | SecretFieldDefinition;\n    interface BaseFieldDefinition {\n            label: string;\n            description?: string;\n            configKey: string;\n            templateSupport?: boolean;\n            typeConfigurable?: boolean;\n            aiCompletion?: {\n                    prompt: string;\n                    placeholder?: string;\n                    jsonMode?: boolean;\n            };\n            /**\n                * Optional condition that determines whether this field should be shown.\n                * If the condition evaluates to false, the field will be hidden.\n                *\n                * Uses a string expression like \"method !== 'GET'\" that will be evaluated against the values.\n                * The expression can reference other field values directly by their key.\n                *\n                * @example\n                * condition: \"method === 'POST'\"\n                */\n            condition?: string;\n    }\n    export interface StringFieldDefinition extends BaseFieldDefinition {\n            type: \"string\";\n    }\n    export interface BooleanFieldDefinition extends BaseFieldDefinition {\n            type: \"boolean\";\n    }\n    export interface JsonFieldDefinition extends BaseFieldDefinition {\n            type: \"json\";\n            typeData?: {\n                    helperText?: string;\n            };\n    }\n    export interface LongTextFieldDefinition extends BaseFieldDefinition {\n            type: \"longtext\";\n            typeData?: {\n                    rows?: number;\n            };\n    }\n    export interface NumberFieldDefinition extends BaseFieldDefinition {\n            type: \"number\";\n            typeData?: NumberTypeData;\n    }\n    export interface SelectFieldDefinition extends BaseFieldDefinition {\n            type: \"select\";\n            typeData: SelectTypeData;\n    }\n    export interface SecretFieldDefinition extends BaseFieldDefinition {\n            type: \"secret\";\n            typeData: SecretTypeData;\n    }\n    export interface NumberTypeData {\n            min?: number;\n            max?: number;\n    }\n    export interface SecretTypeData {\n            defaultName?: string;\n    }\n    export interface SelectTypeData {\n            options: {\n                    value: string | number;\n                    label: string;\n            }[];\n    }\n    export interface ConfigurableEditorConfigCustom {\n            type: \"custom\";\n            editorComponentBundlePath?: string;\n            editorComponentBundleContent?: string;\n    }\n    export interface ConfigurableEditorConfigStructured {\n            type: \"structured\";\n            fields: ConfigurableFieldDefinition[];\n    }\n    export type ConfigurableEditorConfigResolved = ConfigurableEditorConfigCustom | ConfigurableEditorConfigStructured;\n    export type ConfigurableEditorConfigDefinition = ConfigurableEditorConfigCustom | ConfigurableEditorConfigStructured;\n    export interface InternalMacroNode<T = any> extends NodeMetadata {\n            definitionBuilder: (data: T) => Omit<CodeNodeDefinition, \"id\" | \"namespace\">;\n            runFnBuilder: (data: T) => InternalCodeNode[\"run\"];\n            defaultData: T;\n            /**\n                * Assumes you are bundling the editor component using webpack library+window config.\n                * The name of the window variable that holds the component should be __MacroNode__{id}\n                * The path should be relative to the root of the project (package.json location)\n                */\n            editorConfig: ConfigurableEditorConfigResolved;\n    }\n    export type ConfigurableNodeDefinition<T> = Omit<InternalMacroNode<T>, \"definitionBuilder\" | \"runFnBuilder\" | \"editorComponentBundlePath\" | \"editorConfig\"> & {\n            /**\n                * Resolver will use this to load the editor component bundle into the editor\n                */\n            editorConfig: ConfigurableEditorConfigDefinition;\n            sourceCode?: string;\n    };\n    export interface AiCompletionDto {\n            prompt: string;\n            nodeId: string;\n            insId: string;\n            jsonMode?: boolean;\n    }\n    export interface PartialEditorPorts {\n            getAvailableSecrets: () => Promise<string[]>;\n            addNewSecret: (dto: {\n                    key: string;\n                    value: string;\n            }) => Promise<string[]>;\n            prompt: ({ text, defaultValue }: {\n                    text: string;\n                    defaultValue?: string;\n            }) => Promise<string | null>;\n            createAiCompletion?: (dto: AiCompletionDto) => Promise<string>;\n    }\n    export interface ConfigurableEditorCompProps<T> {\n            value: T;\n            onChange: (value: T) => void;\n            ports: PartialEditorPorts;\n            insId?: string;\n            nodeId: string;\n            createAiCompletion?: PartialEditorPorts['createAiCompletion'];\n    }\n    export interface ConfigurableEditorComp<T> extends React.FC<ConfigurableEditorCompProps<T>> {\n    }\n    export const isInternalMacroNode: (p: any) => p is InternalMacroNode<any>;\n    export function processConfigurableNodeInstance(prefix: string, _macro: InternalMacroNode<any> | CodeNode, instance: Pick<CodeNodeInstance, \"id\" | \"config\">, secrets?: Record<string, string>): InternalCodeNode;\n    export interface GroupFieldDefinition extends BaseFieldDefinition {\n            type: \"group\";\n            fields: ConfigurableFieldDefinition[];\n            typeData?: {\n                    /**\n                        * Whether the group is collapsible\n                        */\n                    collapsible?: boolean;\n                    /**\n                        * Whether the group is collapsed by default (only applies if collapsible is true)\n                        */\n                    defaultCollapsed?: boolean;\n            };\n    }\n    export function isConfigurableValue(value: any): value is ConfigurableValue;\n    export {};\n}\n\ndeclare module '@flyde/core/execute/debugger' {\n    import { DebuggerEvent } from \"@flyde/core/execute/debugger/events\";\n    export * from \"@flyde/core/execute/debugger/events\";\n    export * from \"@flyde/core/execute/debugger/format-event\";\n    export type DebuggerInterceptCommand = {\n        cmd: \"intercept\";\n        valuePromise: Promise<any>;\n    };\n    export type DebuggerCommand = DebuggerInterceptCommand | void;\n    export type Debugger = {\n        onEvent?: <T extends DebuggerEvent>(event: Omit<T, \"time\" | \"executionId\">) => DebuggerCommand;\n        debugDelay?: number;\n        destroy?: () => void;\n    };\n}\n\ndeclare module '@flyde/core/' {\n    export * from \"@flyde/core/common\";\n    import { Pos } from \"@flyde/core/common\";\n    import { FlydeFlow } from \"@flyde/core/flow-schema\";\n    import { VisualNode, InputPinsConfig } from \"@flyde/core/node\";\n    export * from \"@flyde/core/connect/helpers\";\n    export * from \"@flyde/core/execute\";\n    export * from \"@flyde/core/simplified-execute\";\n    export * from \"@flyde/core/node\";\n    export * from \"@flyde/core/flow-schema\";\n    export * from \"@flyde/core/types/connections\";\n    export * from \"@flyde/core/types/editor\";\n    export * from \"@flyde/core/configurable-nodes/configurable-nodes\";\n    export { extractInputsFromValue, replaceInputsInValue, renderDerivedString, evaluateCondition, evaluateFieldVisibility, createInputGroup, } from \"@flyde/core/configurable-nodes/configurable-node-utils\";\n    export * from \"@flyde/core/remote-debugger\";\n    export * from \"@flyde/core/run-node\";\n    export interface InstanceViewData {\n        id: string;\n        nodeIdOrGroup: string | VisualNode;\n        pos: Pos;\n        visibleOptionalInputs?: string[];\n        inputConfig: InputPinsConfig;\n    }\n    export interface FlowJob {\n        flow: FlydeFlow;\n        id: string;\n    }\n    export * from \"@flyde/core/telemetry\";\n}\n\ndeclare module '@flyde/core/remote-debugger/types' {\n    import { DebuggerEvent } from \"@flyde/core/execute/debugger/events\";\n    export type RemoteDebuggerCallback<T> = (data: T) => void;\n    export type RemoteDebuggerCancelFn = () => void;\n    export enum DebuggerServerEventType {\n        RUNTIME_READY = \"runtime-ready\",\n        CHANGE_EVENT_NAME = \"change\",\n        PUSH_INPUT_VALUE = \"push-input-value\",\n        CHANGE_AWK = \"live-change-awk\",\n        CHANGE_ERROR = \"live-change-error\",\n        IS_ALIVE = \"is-alive\",\n        UPDATE_BREAKPOINTS = \"update-breakpoints\",\n        INPUT_VALUE_OVERRIDE = \"input-value-override\",\n        OUTPUT_VALUE_OVERRIDE = \"output-value-override\",\n        INPUT_VALUE_CHANGE = \"input-value-changed\",\n        OUTPUT_VALUE_CHANGE = \"output-value-changed\",\n        PROCESSING_CHANGE = \"processing-changed\",\n        INPUTS_STATE_CHANGE = \"inputs-state-changed\",\n        NODE_ERROR = \"node-error\",\n        EVENTS_BATCH = \"events-batch\"\n    }\n    export type HistoryPayload = {\n        total: number;\n        lastSamples: DebuggerEvent[];\n    };\n}\n\ndeclare module '@flyde/core/remote-debugger/utils' {\n    export const toString: (v: any) => string;\n    export const valuePreview: (v: any) => string;\n    export const isSimpleType: (v: any) => boolean;\n    export const isNumber: (v: any) => boolean;\n    export function enumToArray(aEnum: any): any[];\n}\n\ndeclare module '@flyde/core/types/external' {\n    /**\n        * A visual node is what makes Flyde special. It represents a node created visually in the editor.\n        * It consists of node instances and connections. Each node instance will either refer to an imported node (by id), or include the node \"inline\".\n        * Each connection will represent a \"wire\" between 2 instances, or between an instance and a main input/output pin.\n        * Connecting to a main input or output is the way that a visual nodes' internal implementation can communicate with its external API.\n        */\n    import { CodeNode, CodeNodeInstance, CodeNodeSource, EditorNodeInstance, InputPinsConfig, NodeInstance, VisualNodeInstance, VisualNodeSource } from \"@flyde/core/\";\n    import { OMap, Pos } from \"@flyde/core/common\";\n    import { ConnectionData } from \"@flyde/core/types/connections\";\n    import { BaseNode } from \"@flyde/core/types/core\";\n    import { InternalCodeNode } from \"@flyde/core/types/internal\";\n    export interface VisualNode extends BaseNode {\n            /** a map holding the position for each main input. Used in the editor only. */\n            inputsPosition: OMap<Pos>;\n            /** a map holding the position for each main output. Used in the editor only. */\n            outputsPosition: OMap<Pos>;\n            /** the visual nodes internal node instances, either referring to other nodes by id or by value (inline) */\n            instances: NodeInstance[];\n            /** each connection represents a \"wire\" between 2 different instances, or between an instance and a main input/output*/\n            connections: ConnectionData[];\n    }\n    export const isVisualNode: (p: FlydeNode) => p is VisualNode;\n    export const visualNode: import(\"..\").TestDataCreator<VisualNode>;\n    export function nodeInstance(insId: string, nodeId: string, source: CodeNodeSource, config?: any, inputConfig?: InputPinsConfig, pos?: Pos): CodeNodeInstance;\n    export function visualNodeInstance(insId: string, nodeId: string, source: VisualNodeSource, inputConfig?: InputPinsConfig, pos?: Pos): VisualNodeInstance;\n    export function inlineVisualNodeInstance(insId: string, node: VisualNode, inputConfig?: InputPinsConfig, pos?: Pos): VisualNodeInstance;\n    export type CodeNodeDefinition = Omit<InternalCodeNode, \"run\"> & {\n            /**\n                * The source code of the node, if available. Used for editing and forking nodes in the editor.\n                */\n            sourceCode?: string;\n            /**\n                * Whether this node is a trigger node.\n                * If true, the node will be treated as a trigger node and will not be editable.\n                * Experimental\n                * @default false\n                */\n            isTrigger?: boolean;\n    };\n    export type FlydeNode<T = any> = VisualNode | CodeNode<T>;\n    export type ImportableEditorNode = {\n            id: string;\n            displayName: string;\n            description: string;\n            icon: string;\n            aliases?: string[];\n            editorNode: EditorNodeInstance['node'];\n    } & ({\n            type: \"code\";\n            source: CodeNodeSource;\n            config: any;\n    } | {\n            type: \"visual\";\n            source: VisualNodeSource;\n    });\n    export function codeNodeToImportableEditorNode(node: CodeNode, source: CodeNodeSource): ImportableEditorNode;\n    export function visualNodeToImportableEditorNode(node: VisualNode, source: VisualNodeSource): ImportableEditorNode;\n    export interface NodeLibraryGroup {\n            title: string;\n            nodes: ImportableEditorNode[];\n    }\n    export interface NodeLibraryData {\n            groups: NodeLibraryGroup[];\n    }\n}\n\ndeclare module '@flyde/core/types/internal' {\n    import { InputPinsConfig, RunNodeFunction } from \"@flyde/core/node\";\n    import { ConnectionData } from \"@flyde/core/types/connections\";\n    import { BaseNode } from \"@flyde/core/types/core\";\n    export interface InternalCodeNode extends BaseNode {\n        /**\n          * This function will run as soon as the node's inputs are satisfied.\n          * It has access to the nodes inputs values, and output pins. See {@link RunNodeFunction} for more information.\n          *\n          */\n        run: RunNodeFunction;\n    }\n    export interface InternalCodeNodeInstance {\n        id: string;\n        node: InternalCodeNode;\n        inputConfig: InputPinsConfig;\n    }\n    export interface InternalInlineNodeInstance {\n        id: string;\n        node: InternalVisualNode;\n        inputConfig: InputPinsConfig;\n    }\n    export type InternalNodeInstance = InternalCodeNodeInstance | InternalInlineNodeInstance;\n    export function isInternalInlineNodeInstance(instance: InternalNodeInstance): instance is InternalInlineNodeInstance;\n    export interface InternalVisualNode extends BaseNode {\n        /** the visual nodes internal node instances, either referring to other nodes by id or by value (inline) */\n        instances: InternalNodeInstance[];\n        /** each connection represents a \"wire\" between 2 different instances, or between an instance and a main input/output*/\n        connections: ConnectionData[];\n    }\n    export type InternalNode = InternalCodeNode | InternalVisualNode;\n    export function internalNodeInstance(insId: string, node: InternalNode, inputConfig?: InputPinsConfig): InternalNodeInstance;\n    export function isInternalVisualNode(node: InternalNode): node is InternalVisualNode;\n}\n\ndeclare module '@flyde/core/types/core' {\n    import { InputPin, OutputPin } from \"@flyde/core/types/pins\";\n    export type NodeTypeIcon = string | [string, string];\n    export interface NodeStyle {\n            color?: string | [string, string];\n            cssOverride?: Record<string, string>;\n    }\n    export interface NodeMetadata {\n            /**\n                * Node's unique id. {@link VisualNode.instances }  refer use this to refer to the correct node\n                */\n            id: string;\n            /**\n                * A human readable name for the node. Used in the visual editor.\n                */\n            displayName?: string;\n            menuDisplayName?: string;\n            /**\n                * Is displayed in the visual editor and used to search for nodes.\n                */\n            description?: string;\n            /**\n                * A list of keywords that can be used to search for the node. Useful for node that users might search using different words.\n                */\n            aliases?: string[];\n            /**\n                * TBD\n                */\n            namespace?: string;\n            icon?: string;\n            /**\n                * All instances of this node will inherit the default style if it is supplied.\n                * See {@link NodeStyle} for the full options supported\n                */\n            defaultStyle?: NodeStyle;\n            /**\n                * Hack to support note node without adding first class support for it.\n                * This is used to override the node body html for a node.\n                */\n            overrideNodeBodyHtml?: string;\n    }\n    /**\n        * Extended by {@link VisualNode}, {@link InternalCodeNode} and {@link InlineValueNode}\n        */\n    export interface BaseNode extends NodeMetadata {\n            /**\n                * A pin on a node that receives data. Each node can have zero or more input pins.\n                *\n                * Example for the inputs of a mathematical multiplier node:\n                * ```ts\n                * {\n                *  multiplicand: { description: \"The number to be multiplied\" },\n                *  multiplier: { description: \"The number with which we multiply\" },\n                * }\n                * ```\n                */\n            inputs: Record<string, InputPin>;\n            /**\n                * A pin on a node that sends data. Each node can have zero or more output pins.\n                * For example, a \"Split array\" node might have one input pin for an array and two output pins for the first and second halves of the array:\n                *\n                * @example\n                * ```ts\n                * {\n                *  'first half': { description: \"The first half of the array\" },\n                *  'second half': { description: \"The second half of the array\" },\n                * }\n                * ```\n                */\n            outputs: Record<string, OutputPin>;\n            /**\n                * Instructs Flyde that the node is in \"explicit completion\" mode and describes which outputs trigger the node's completion. Receives a list of outputs that should trigger an explicit completion of the node when they emit a value. Any of the listed outputs will trigger a completion (i.e. completionOutput[0] `OR` completionOutput[1])\n                * Leave empty for implicit completion. This should work best for 99% of the case.\n                *\n                * To declare that 2 different outputs must emit a value in order to trigger a completion, different outputs can be joined together with a `+` sign as following:\n                * ``` ts\n                * {\n                * ...\n                *  completionOutputs: [\"data+headers\", \"error\"] // this means either data AND headers, OR \"error\" will trigger an explicit completion.\n                * ```\n                *\n                * See the [Nodes lifecycle](/docs/lifecycle) for more info\n                */\n            completionOutputs?: string[];\n            /**\n                * @deprecated - TBD\n                */\n            reactiveInputs?: string[];\n    }\n}\n\ndeclare module '@flyde/core/types/pins' {\n    import { Subject } from \"rxjs\";\n    import { OMapF } from \"@flyde/core/\";\n    import { QueueInputPinConfig, StickyInputPinConfig } from \"@flyde/core/types/pin-config\";\n    export type PinType = \"input\" | \"output\";\n    export type InputMode = \"optional\" | \"required\" | \"required-if-connected\";\n    export interface BasePinData {\n        description?: string;\n    }\n    export interface InputPin extends BasePinData {\n        mode?: InputMode;\n    }\n    export type InputPinMap = Record<string, InputPin>;\n    export type OutputPinMap = Record<string, OutputPin>;\n    export interface OutputPin extends BasePinData {\n        delayed?: boolean;\n    }\n    export const nodeInput: (mode?: InputMode) => InputPin;\n    export const isInputPinOptional: (input: InputPin) => boolean;\n    export const nodeInputs: (count: number, modes?: InputMode[]) => InputPin[];\n    export const nodeOutput: (delayed?: boolean) => OutputPin;\n    export const nodeOutputs: (count: number) => OutputPin[];\n    export type DynamicNodeInput = {\n        subject: Subject<any>;\n        config: StickyInputPinConfig | QueueInputPinConfig;\n    };\n    export type NodeInput = DynamicNodeInput;\n    export type NodeOutput = Subject<any>;\n    export type NodeOutputs = OMapF<NodeOutput>;\n    export type NodeInputs = OMapF<NodeInput>;\n    export interface DynamicOutput extends Subject<any> {\n    }\n    export const dynamicOutput: () => DynamicOutput;\n    export const dynamicNodeInput: import(\"..\").TestDataCreator<DynamicNodeInput>;\n    export const dynamicNodeInputs: (count?: number) => DynamicNodeInput[];\n}\n\ndeclare module '@flyde/core/execute/debugger/events' {\n    import { OMap } from \"@flyde/core/\";\n    export enum DebuggerEventType {\n        INPUT_CHANGE = \"i\",\n        OUTPUT_CHANGE = \"o\",\n        PROCESSING_CHANGE = \"pc\",\n        ERROR = \"err\",\n        INPUTS_STATE_CHANGE = \"isc\"\n    }\n    export const MAJOR_DEBUGGER_EVENT_TYPES: DebuggerEventType[];\n    export const MINOR_DEBUGGER_EVENT_TYPES: DebuggerEventType[];\n    export type BaseDebuggerEvent<T extends DebuggerEventType> = {\n        type: T;\n        insId: string;\n        ancestorsInsIds?: string;\n        nodeId: string;\n        val: DebuggerEventTypeData[T];\n        time: number;\n        executionId: string;\n    };\n    export type PinDebuggerEvent<T extends DebuggerEventType> = {\n        pinId: string;\n    } & BaseDebuggerEvent<T>;\n    export type DebuggerEventTypeData = {\n        [DebuggerEventType.INPUTS_STATE_CHANGE]: OMap<number>;\n        [DebuggerEventType.PROCESSING_CHANGE]: boolean;\n        [DebuggerEventType.ERROR]: any;\n        [DebuggerEventType.INPUT_CHANGE]: string;\n        [DebuggerEventType.OUTPUT_CHANGE]: string;\n    };\n    export type MajorDebuggerEvent = PinDebuggerEvent<DebuggerEventType.OUTPUT_CHANGE> | PinDebuggerEvent<DebuggerEventType.INPUT_CHANGE> | BaseDebuggerEvent<DebuggerEventType.ERROR>;\n    export type MinorDebuggerEvent = BaseDebuggerEvent<DebuggerEventType.INPUTS_STATE_CHANGE> | BaseDebuggerEvent<DebuggerEventType.PROCESSING_CHANGE>;\n    export type DebuggerEvent = MajorDebuggerEvent | MinorDebuggerEvent;\n}\n\ndeclare module '@flyde/core/execute/debugger/format-event' {\n    import { DebuggerEvent } from \"@flyde/core/execute/debugger/events\";\n    export function formatEvent(event: DebuggerEvent): string;\n}\n\n";
//# sourceMappingURL=flyde-core-types.d.ts.map